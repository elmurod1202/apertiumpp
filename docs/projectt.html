<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-04-30 Tue 17:50 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PROJECT T, or APERTIUM++!</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">PROJECT T, or APERTIUM++!</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga7e7820">1. OBJECTIVES</a></li>
<li><a href="#orge62202f">2. RATIONALE</a></li>
<li><a href="#orgf34d174">3. WHAT WAS DONE</a></li>
<li><a href="#org3606554">4. WORKING ON / NEEDED</a>
<ul>
<li><a href="#orgf27b614">4.1. Resources</a>
<ul>
<li><a href="#org12677d8">4.1.1. Multilingual dictionary</a>
<ul>
<li><a href="#orgb589a98">4.1.1.1. RATIONALE</a></li>
<li><a href="#org536dd1f">4.1.1.2. OBJECTIVES</a></li>
<li><a href="#org62725bf">4.1.1.3. CONSTRAINTS</a></li>
<li><a href="#orge46a6d4">4.1.1.4. OPTIONS</a>
<ul>
<li><a href="#org7413e2e">4.1.1.4.1. Wordnet</a></li>
</ul>
</li>
<li><a href="#orgc547cac">4.1.1.5. WHAT WAS DONE</a>
<ul>
<li><a href="#org5bcf45e">4.1.1.5.1. A library for converting two or more Apertium bidixes into a wordgraph</a></li>
<li><a href="#org4579c8d">4.1.1.5.2. A script for converting English Wordnet leammas into Turkic languages</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge71ff2b">4.1.2. Parallel corpus</a></li>
</ul>
</li>
<li><a href="#org55c81e2">4.2. Connecting nodes</a>
<ul>
<li><a href="#org3bef536">4.2.1. Nodes: Morphological Transducers</a></li>
<li><a href="#org3320ce5">4.2.2. To English</a></li>
<li><a href="#orgc7aa48e">4.2.3. To Russian</a></li>
<li><a href="#org8495616">4.2.4. Intraturkic</a>
<ul>
<li><a href="#org798e311">4.2.4.1. apertium-tat-bak, apertium-kaz-tat, apertium-chv-tat, apertium-tur-tat, apertium-crh-tur&#x2026;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgf84a07a">4.3. QA and meta-stuff</a>
<ul>
<li><a href="#org57afacb">4.3.1. apertium fitnesse</a></li>
<li><a href="#org21a0c1e">4.3.2. rbmt-as-a-data-structure = a (Racket-based?) programming language with a syntax similar to what is seen on http://fitnesse.selimcan.org/FrontPage.ApertiumTurkic.ApertiumKaz.</a>
<ul>
<li><a href="#org3821270">4.3.2.1. Rationale</a></li>
<li><a href="#orge9d6620">4.3.2.2. Code</a></li>
</ul>
</li>
<li><a href="#orgd49cdc0">4.3.3. Problem 404</a>
<ul>
<li><a href="#orgf038608">4.3.3.1. Problem 404.a</a></li>
<li><a href="#orgfcbfcd2">4.3.3.2. Problem 404.b</a></li>
<li><a href="#org77df442">4.3.3.3. Problem 404.c</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgac7e3f6">5. ROADMAP</a></li>
<li><a href="#orgd7218a7">6. NOTES</a>
<ul>
<li><a href="#orge7d67f9">6.1. Methods of auditing a monolingual dictionary</a></li>
<li><a href="#orgca16a17">6.2. Principles of tagset choice</a></li>
<li><a href="#org8a8f575">6.3. Minimal monolingual Apertiumpp package</a></li>
</ul>
</li>
<li><a href="#org2d5a29e">7. TODAY</a></li>
<li><a href="#orgb3e7728">8. ON THE NEXT "META"-WORK DAY</a></li>
<li><a href="#org41edc63">9. ON THE NEXT "APERTIUM-TURKIC LINGUISTIC DATA" DAY</a></li>
</ul>
</div>
</div>
<p>
This page documents research carried over in the <a href="https://taruen.github.io/apertiumpp/">Apertiumpp project</a>.
</p>

<div id="outline-container-orga7e7820" class="outline-2">
<h2 id="orga7e7820"><span class="section-number-2">1</span> OBJECTIVES</h2>
<div class="outline-text-2" id="text-1">
<p>
Enabling machine translation:
</p>

<ol class="org-ol">
<li>from any Turkic language to any other Turkic language,</li>
<li>between any Turkic language and English, and</li>
<li>between any Turkic language and Russian.</li>
</ol>

<p>
What we're after:
</p>

<ol class="org-ol">
<li>Machine translators themselves.</li>
<li>Description of the process and infrastructure for solving the same problem
for another family of languages in the most efficient manner.</li>
<li>Better yet, a program which asks native speakers the right questions in the
right order, judges whether answers are reliable, and writes machine
translators for us.</li>
<li>Text-to-speech systems.</li>
<li>Speech recognition systems.</li>
<li>Annotated corpora with a standard interface.</li>
<li>Spellcheckers (and keyboard layouts, if missing).</li>
</ol>

<p>
Somewhat more formally:
</p>

<div class="problem">
<p>
(<b>Begin Problem 1</b>
</p>

<p>
Given:
</p>

<p>
Set \(L = \{l_1, l_2, ..., l_n\}\) of languages of one language family.
</p>

<p>
Unknown:
</p>

<p>
Algorithm for obtaining machine translators \(t_i ... t_{n * (n-1)+2n}\) from
\(l_1\) to \(l_2\) where \(l_1 \in L\) and \(l_2 \in L \cup \{eng, rus\}\) and machine
translators themselves, including spech-to-text and text-to-speech frontends
and annotated corpora.
</p>

<p>
Conditions:
</p>

<ol class="org-ol">
<li>\(Word Error Rate(t_i) < THRESHOLD\) for every \(i\).</li>
<li>As a byproduct, the process generates a standalone morphological analyzer
(applicable as a spellchecker), dependency and/or semantic parser, speech
recognizer and speech synthesizer for every \(l \in L\).</li>
</ol>
<p>
<b>End Problem 1</b>)
</p>

</div>

<p>
In our case, \(L = \{kaz, tat, kir, tyv, tur, chv, kum, kaa, uzb, sah, crh, krc,
 bak, nog, gag, tuk, uig, alt, kjh, ota, aze\}\).
</p>

<p>
We want a connected graph (not necessarily complete, if we pivot) consisting of
the nodes in \(L\) + a path from every node in \(L\) to \(eng\) and \(rus\). Two nodes
are considered connected if there is a (<a href="http://wiki.apertium.org/wiki/Mixed_modes">mixed</a>) <a href="http://wiki.apertium.org/wiki/Modes">mode</a> for translating between them
(in both directions).
</p>
</div>
</div>

<div id="outline-container-orge62202f" class="outline-2">
<h2 id="orge62202f"><span class="section-number-2">2</span> RATIONALE</h2>
<div class="outline-text-2" id="text-2">
<p>
Applications:
</p>
<ul class="org-ul">
<li>translating Khanacademy's content (Creative Commons BY-NC-SA 3.0 US)</li>
<li>translating (English) Wikipedia (Creative Commons BY-SA 3.0 Unported)
<ul class="org-ul">
<li><a href="https://meta.wikimedia.org/wiki/List_of_articles_every_Wikipedia_should_have">articles every Wikipedia should have</a></li>
<li>selected articles of other Wikipedias</li>
</ul></li>
<li>localizing free/libre software</li>
<li>translating other resources listed on <a href="http://selimcan.org/tat/about.html">http://selimcan.org/tat/about.html</a></li>
<li>components used as spell and grammar checkers and in QA systems</li>
</ul>
</div>
</div>

<div id="outline-container-orgf34d174" class="outline-2">
<h2 id="orgf34d174"><span class="section-number-2">3</span> WHAT WAS DONE</h2>
<div class="outline-text-2" id="text-3">
<p>
See <a href="http://wiki.apertium.org/wiki/Turkic_languages">http://wiki.apertium.org/wiki/Turkic_languages</a>.
</p>
</div>
</div>

<div id="outline-container-org3606554" class="outline-2">
<h2 id="org3606554"><span class="section-number-2">4</span> WORKING ON / NEEDED</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgf27b614" class="outline-3">
<h3 id="orgf27b614"><span class="section-number-3">4.1</span> Resources</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>multilingual dictionary
<ul class="org-ul">
<li>closed class words</li>
<li>nouns, adjectives, verbs, adverbs</li>
<li>proper nouns / named entities</li>
</ul></li>
<li>parallel corpus</li>
<li>parallel tagged corpus</li>
<li>parallel treebank</li>
<li>multilingual dictionary of idioms (a translation memory)</li>
<li>spoken texts (under CC0, CC-BY, CC-BY-SA or compatible licenses)</li>
<li>a mobile app which collects all of the above from the volunteer contributors</li>
</ul>
</div>

<div id="outline-container-org12677d8" class="outline-4">
<h4 id="org12677d8"><span class="section-number-4">4.1.1</span> Multilingual dictionary</h4>
<div class="outline-text-4" id="text-4-1-1">
</div>
<div id="outline-container-orgb589a98" class="outline-5">
<h5 id="orgb589a98"><span class="section-number-5">4.1.1.1</span> RATIONALE</h5>
<div class="outline-text-5" id="text-4-1-1-1">
<p>
\(n\) languages make up \(\sum_{i=1}^{n-1} i\) bilingual machine translators. For 21
languages in \(L\) listed above, \(\sum_{i=1}^{21-1} i = 210\). We don't want to
maintain \(\sum_{i=1}^{n-1} i\) separate bidixes for translating between \(n\)
languages (even not considering \(rus\) and \(eng\), no pivoting, 210 for
\(n=21\)). In fact, we probably don't wan't to maintain 20 dictionaries with the
same left side either (always pivoting through the same language), but that
might be feasible.
</p>
</div>
</div>

<div id="outline-container-org536dd1f" class="outline-5">
<h5 id="org536dd1f"><span class="section-number-5">4.1.1.2</span> OBJECTIVES</h5>
<div class="outline-text-5" id="text-4-1-1-2">
<p>
A multilingual dictionary from which individual monolingual and
bilingual dictionaries can be generated.
</p>

<p>
TODO a representation/format for the multidix
</p>
<ul class="org-ul">
<li>see <a href="http://wiki.apertium.org/wiki/User:Unhammer/wishlist">Unhammer's wishlist</a> for details</li>
<li>entries contain:
<ul class="org-ul">
<li>stem</li>
<li>the LEXICON(s)/pardef(s) the stem should be linked to in the monodix</li>
<li>tags which should end up in the bidix (or a bidix pardef)</li>
<li>alternative or erroneous spellings (LR/RL forms)</li>
<li>other attributes (language variant, style, archaic or not etc)</li>
<li>example sentences with the word in question</li>
</ul></li>
<li>options:
<ul class="org-ul">
<li>a DTD based on dix.dtd?</li>
</ul></li>
</ul>

<p>
TODO a program which converts Apertium mono- and bidixes into a multidix
</p>

<p>
See <a href="#org9ea6311">1</a> and <a href="#orgf058c15">1</a>.
</p>

<p>
TODO a program which converts a multidix into Apertium monodixes and bidixes
</p>
</div>
</div>

<div id="outline-container-org62725bf" class="outline-5">
<h5 id="org62725bf"><span class="section-number-5">4.1.1.3</span> CONSTRAINTS</h5>
<div class="outline-text-5" id="text-4-1-1-3">
<ul class="org-ul">
<li>should be writable by monolingual Turkic speakers (speakers of only
one Turkic language, that is. Knowledge of English or Russian is assumed,
since otherwise the only reliable linkage would be pictures).</li>
</ul>
</div>
</div>

<div id="outline-container-orge46a6d4" class="outline-5">
<h5 id="orge46a6d4"><span class="section-number-5">4.1.1.4</span> OPTIONS</h5>
<div class="outline-text-5" id="text-4-1-1-4">
<ul class="org-ul">
<li>pivoting
<ul class="org-ul">
<li>translating entries from a public domain/libre English dictionary
<ul class="org-ul">
<li>Wordnet? GNU collaborative dictionary of English? Wiktionary?
OmegaWiki?</li>
</ul></li>
<li>same for Russian (if there is any available&#x2026;)
<ul class="org-ul">
<li>DONE check [<a href="https://en.wikipedia.org/wiki/Ushakov_Dictionary">https://en.wikipedia.org/wiki/Ushakov_Dictionary</a>] might be in
the public domain now
<ul class="org-ul">
<li>Dmitry Nikolayevich Ushakov died in 1942, and all 4 volumes of the dictionary
were published in 1935-1940, which means that all of them are in the public
domain now in Russian Federation.</li>
</ul></li>
</ul></li>
<li>translating entries from a libre Turkic dictionary
<ul class="org-ul">
<li>is there any? Probably not.
<ul class="org-ul">
<li>DONE email publishers (<del><a href="http://www.twirpx.com/file/1077154">this</a> one is of interest</del>. No reason for using an
older edition given that we have a permission to use newer ones now)
<ul class="org-ul">
<li>Ibrahimov Institute of Language, Literature and Art @ Tatarstan
Academy of Sciences in email communication allowed to use the entries
from the currently 3-volume (А-К) ``Татар теленең
аңлатмалы сүзлеге'' (``Explanatory Dictionary of Tatar'') found here
<a href="http://www.antat.ru/tt/iyli/publishing/book/index.php">http://www.antat.ru/tt/iyli/publishing/book/index.php</a>, as well as entries
from the 2013 ~``Explanatory Dictionary of Tatar for Schools'' in
Apertium's dictionaries. Which means that we have at least one Turkic
explanatory dictionary (with parts-of-speech info and examples) we can
use in Apertium.</li>
</ul></li>
<li>TODO ask Kazakhstani colleagues to do the same kind of negotiations
about the <a href="https://kitap.kz/">Universal Dictionary of Kazakh</a> (Қазақ тілінің әмбебап
сөздігі). Read: can we get a permission to use it for making a
free/open-source morphological analyser for Kazakh (in Apertium) and
publish its contents under GPLv3 and/or CC BY-SA license?</li>
</ul></li>
<li><del>even if there is one, allowing a monolingual Turkic speaker to translate</del>
<del>words into his own language will require translating the <b>definitions</b> into</del>
<del>English or Russian, which is a huge amount of work compared to translating</del>
<del>the words only</del> The idea here is to use the very same turkic-turkic translators
as we get them by translating entry words for translating entry examples and
definitions.</li>
</ul></li>
</ul></li>

<li>inducing from bilingual corpora</li>

<li>inducing from monolingual corpora
<ul class="org-ul">
<li>Haghighi, A., Liang, P., Berg-Kirkpatrick, T., &amp; Klein, D. (2008,
June). Learning Bilingual Lexicons from Monolingual Corpora. In
ACL (Vol. 2008, pp. 771-779).</li>
<li>Koehn, P., &amp; Knight, K. (2002, July). Learning a translation
lexicon from monolingual corpora. In Proceedings of the ACL-02
workshop on Unsupervised lexical acquisition-Volume 9
(pp. 9-16). Association for Computational Linguistics.</li>
<li>&#x2026;</li>
</ul></li>

<li><p>
currently apertium-eng-kaz.eng-kaz.dix has roughly
</p>
<div class="org-src-container">
<pre class="src src-sh" id="org92aa4b2">grep -c <span style="color: #CC9393;">"&lt;e&gt;"</span> ../apertium-all/apertium-trunk/apertium-eng-kaz/apertium-eng-kaz.eng-kaz.dix
</pre>
</div>

<pre class="example">
32886

</pre>

<p>
entries in it.
</p></li>

<li>also see: <a href="http://wiki.apertium.org/wiki/Bilingual_dictionary_discovery">http://wiki.apertium.org/wiki/Bilingual_dictionary_discovery</a></li>
</ul>
</div>

<div id="outline-container-org7413e2e" class="outline-6">
<h6 id="org7413e2e"><span class="section-number-6">4.1.1.4.1</span> Wordnet</h6>
<div class="outline-text-6" id="text-4-1-1-4-1">
<ul class="org-ul">
<li>experiences with translating English Wordnet into another language?
<ul class="org-ul">
<li>Lindén, K., &amp; Carlson, L. (2010). FinnWordNet–Finnish WordNet by
Translation. LexicoNordica–Nordic Journal of Lexicography, 17,
119-140.</li>
<li>Lindén, K., &amp; Niemi, J. (2014). Is it possible to create a very large
wordnet in 100 days? An evaluation. Language resources and evaluation,
48(2), 191-201.</li>
<li>Isahara, H., Bond, F., Uchimoto, K., Utiyama, M., &amp; Kanzaki,
K. (2008). Development of the Japanese WordNet.</li>
<li>Niemi, J., Lindén, K., &amp; Hyvärinen, M. (2012, January). Using a Bilingual
Resource to Add Synonyms to a Wordnet. In Proceedings of the Global Wordnet
Conference.</li>
<li>Bond, F., Isahara, H., Kanzaki, K., &amp; Uchimoto, K. (2008). Boot-strapping a
WordNet using multiple existing WordNets.</li>
<li><a href="http://compling.hss.ntu.edu.sg/omw/">Open Multilingual Wordnet</a></li>
<li><a href="http://globalwordnet.org">Global WordNet Association</a></li>
</ul></li>
<li>pros: free license, no need to scan anything, good for papers</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgc547cac" class="outline-5">
<h5 id="orgc547cac"><span class="section-number-5">4.1.1.5</span> WHAT WAS DONE</h5>
<div class="outline-text-5" id="text-4-1-1-5">
</div>
<div id="outline-container-org5bcf45e" class="outline-6">
<h6 id="org5bcf45e"><span class="section-number-6">4.1.1.5.1</span> A library for converting two or more Apertium bidixes into a wordgraph</h6>
<div class="outline-text-6" id="text-4-1-1-5-1">
<div class="org-src-container">
<pre class="src src-python" id="org9ea6311">
<span style="color: #9FC59F;">"""</span>
<span style="color: #9FC59F;">wordgraph.py</span>

<span style="color: #9FC59F;">A library for converting two or more Apertium bidixes into a Wordgraph (its</span>
<span style="color: #9FC59F;">definition you can see below) and then doing various things with that</span>
<span style="color: #9FC59F;">wordgraph such as:</span>
<span style="color: #9FC59F;">- exporting it as a Multidix, in which entries are *optionally* linked to</span>
<span style="color: #9FC59F;">  English Wordnet's definitions (see bidixes2multidix.py),</span>
<span style="color: #9FC59F;">- translating English Wordnet lemmas to other languages via (chain) lookup</span>
<span style="color: #9FC59F;">  in the wordgraph or in Google/Yandex translate (see enwordnet2twordnet.py),</span>
<span style="color: #9FC59F;">- or generating new bidixes for language pairs for which you didn't have a</span>
<span style="color: #9FC59F;">  bidix before (TODO).</span>

<span style="color: #9FC59F;">USAGE: import wordgraph as wg</span>

<span style="color: #9FC59F;">TODO:</span>
<span style="color: #9FC59F;">  - handle LR RL restrictions</span>
<span style="color: #9FC59F;">"""</span>

<span style="color: #F0DFAF; font-weight: bold;">import</span> xml.etree.ElementTree <span style="color: #F0DFAF; font-weight: bold;">as</span> ET
<span style="color: #F0DFAF; font-weight: bold;">from</span> xml.dom <span style="color: #F0DFAF; font-weight: bold;">import</span> minidom
<span style="color: #F0DFAF; font-weight: bold;">import</span> glob
<span style="color: #F0DFAF; font-weight: bold;">import</span> os.path
<span style="color: #F0DFAF; font-weight: bold;">from</span> collections <span style="color: #F0DFAF; font-weight: bold;">import</span> namedtuple, defaultdict
<span style="color: #F0DFAF; font-weight: bold;">from</span> io <span style="color: #F0DFAF; font-weight: bold;">import</span> StringIO
<span style="color: #F0DFAF; font-weight: bold;">import</span> re
<span style="color: #F0DFAF; font-weight: bold;">from</span> copy <span style="color: #F0DFAF; font-weight: bold;">import</span> deepcopy
<span style="color: #F0DFAF; font-weight: bold;">import</span> sys


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Constants</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">=========</span>


<span style="color: #DFAF8F;">ISO2_2_ISO3</span> = {<span style="color: #CC9393;">'kz'</span>: <span style="color: #CC9393;">'kaz'</span>, <span style="color: #CC9393;">'tt'</span>: <span style="color: #CC9393;">'tat'</span>, <span style="color: #CC9393;">'ky'</span>: <span style="color: #CC9393;">'kir'</span>, <span style="color: #CC9393;">'tr'</span>: <span style="color: #CC9393;">'tur'</span>, <span style="color: #CC9393;">'cv'</span>: <span style="color: #CC9393;">'chv'</span>,
               <span style="color: #CC9393;">'uz'</span>: <span style="color: #CC9393;">'uzb'</span>, <span style="color: #CC9393;">'ba'</span>: <span style="color: #CC9393;">'bak'</span>, <span style="color: #CC9393;">'tk'</span>: <span style="color: #CC9393;">'tuk'</span>, <span style="color: #CC9393;">'ug'</span>: <span style="color: #CC9393;">'uig'</span>, <span style="color: #CC9393;">'az'</span>: <span style="color: #CC9393;">'aze'</span>,
               <span style="color: #CC9393;">'en'</span>: <span style="color: #CC9393;">'eng'</span>}
<span style="color: #DFAF8F;">ISO3_2_ISO2</span> = {<span style="color: #CC9393;">'kaz'</span>: <span style="color: #CC9393;">'kk'</span>, <span style="color: #CC9393;">'tat'</span>: <span style="color: #CC9393;">'tt'</span>, <span style="color: #CC9393;">'kir'</span>: <span style="color: #CC9393;">'ky'</span>, <span style="color: #CC9393;">'tur'</span>: <span style="color: #CC9393;">'tr'</span>, <span style="color: #CC9393;">'chv'</span>: <span style="color: #CC9393;">'cv'</span>,
               <span style="color: #CC9393;">'uzb'</span>: <span style="color: #CC9393;">'uz'</span>, <span style="color: #CC9393;">'bak'</span>: <span style="color: #CC9393;">'ba'</span>, <span style="color: #CC9393;">'tuk'</span>: <span style="color: #CC9393;">'tk'</span>, <span style="color: #CC9393;">'uig'</span>: <span style="color: #CC9393;">'ug'</span>, <span style="color: #CC9393;">'aze'</span>: <span style="color: #CC9393;">'az'</span>,
               <span style="color: #CC9393;">'eng'</span>: <span style="color: #CC9393;">'en'</span>}


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Data definitions</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">================</span>


<span style="color: #DFAF8F;">MonolingEntry</span> = namedtuple(<span style="color: #CC9393;">"MonolingEntry"</span>, [<span style="color: #CC9393;">"lang"</span>, <span style="color: #CC9393;">"lm"</span>, <span style="color: #CC9393;">"tags"</span>])
<span style="color: #5F7F5F;">##</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">MonolingEntry is MonolingEntry(String, String, (Tuple of String))</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">interp.: a monolingual dictionary entry, where:</span>
<span style="color: #5F7F5F;">##          </span><span style="color: #7F9F7F;">- lang is iso3 code of the language</span>
<span style="color: #5F7F5F;">##          </span><span style="color: #7F9F7F;">- lm is the lemma</span>
<span style="color: #5F7F5F;">##          </span><span style="color: #7F9F7F;">- tags are the symbols used in Apertium to denote part-of-speech</span>
<span style="color: #5F7F5F;">##            </span><span style="color: #7F9F7F;">tags and other morphological features (the ones which you'd</span>
<span style="color: #5F7F5F;">##            </span><span style="color: #7F9F7F;">put into a bidix)</span>

<span style="color: #DFAF8F;">MONOLING_E_1</span> = MonolingEntry(<span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">""</span>, ())  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">null translation</span>
<span style="color: #DFAF8F;">MONOLING_E_2</span> = MonolingEntry(<span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"file"</span>, (<span style="color: #CC9393;">"n"</span>,))
<span style="color: #DFAF8F;">MONOLING_E_3</span> = MonolingEntry(<span style="color: #CC9393;">"kaz"</span>, <span style="color: #CC9393;">"&#1092;&#1072;&#1081;&#1083;"</span>, (<span style="color: #CC9393;">"n"</span>,))
<span style="color: #DFAF8F;">MONOLING_E_4</span> = MonolingEntry(<span style="color: #CC9393;">"kaz"</span>, <span style="color: #CC9393;">"&#1077;&#1075;&#1077;&#1091;"</span>, (<span style="color: #CC9393;">"n"</span>,))
<span style="color: #DFAF8F;">MONOLING_E_5</span> = MonolingEntry(<span style="color: #CC9393;">"tat"</span>, <span style="color: #CC9393;">"&#1080;&#1075;&#1241;&#1199;"</span>, (<span style="color: #CC9393;">"n"</span>,))
<span style="color: #DFAF8F;">MONOLING_E_6</span> = MonolingEntry(<span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"Moscow"</span>, (<span style="color: #CC9393;">"np"</span>, <span style="color: #CC9393;">"top"</span>))
<span style="color: #DFAF8F;">MONOLING_E_7</span> = MonolingEntry(<span style="color: #CC9393;">"tat"</span>, <span style="color: #CC9393;">"&#1052;&#1241;&#1089;&#1082;&#1241;&#1199;"</span>, (<span style="color: #CC9393;">"np"</span>, <span style="color: #CC9393;">"top"</span>, <span style="color: #CC9393;">"hargle"</span>))
<span style="color: #DFAF8F;">MONOLING_E_8</span> = MonolingEntry(<span style="color: #CC9393;">"rus"</span>, <span style="color: #CC9393;">"&#1052;&#1086;&#1089;&#1082;&#1074;&#1072;"</span>, (<span style="color: #CC9393;">"np"</span>,))
<span style="color: #DFAF8F;">MONOLING_E_9</span> = MonolingEntry(<span style="color: #CC9393;">"tur"</span>, <span style="color: #CC9393;">"Moskova"</span>, ())


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">A Graph is a Dictionary which maps Object to a (Set of Object).</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">interp.: {node: {its, neighbouring, nodes}</span>

<span style="color: #DFAF8F;">G_1</span> = {<span style="color: #CC9393;">'a'</span>: {<span style="color: #CC9393;">'b'</span>, <span style="color: #CC9393;">'c'</span>},                     <span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">a---b---d---f</span>
       <span style="color: #CC9393;">'b'</span>: {<span style="color: #CC9393;">'a'</span>, <span style="color: #CC9393;">'c'</span>, <span style="color: #CC9393;">'d'</span>},                <span style="color: #5F7F5F;">##  </span><span style="color: #7F9F7F;">\ /</span>
       <span style="color: #CC9393;">'c'</span>: {<span style="color: #CC9393;">'a'</span>, <span style="color: #CC9393;">'b'</span>},                     <span style="color: #5F7F5F;">##   </span><span style="color: #7F9F7F;">c     g  h---i</span>
       <span style="color: #CC9393;">'d'</span>: {<span style="color: #CC9393;">'b'</span>, <span style="color: #CC9393;">'f'</span>},
       <span style="color: #CC9393;">'f'</span>: {<span style="color: #CC9393;">'d'</span>},
       <span style="color: #CC9393;">'g'</span>: {},
       <span style="color: #CC9393;">'h'</span>: {<span style="color: #CC9393;">'i'</span>},
       <span style="color: #CC9393;">'i'</span>: {<span style="color: #CC9393;">'h'</span>}}


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">WordGraph is a Graph which maps MonolingEntry to</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">a (Set of MonolingEntry)</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">interp.: {monoling_e_1: {monoling_e_2, monoling_e_3},</span>
<span style="color: #5F7F5F;">##           </span><span style="color: #7F9F7F;">monoling_e_2: {monoling_e_1},</span>
<span style="color: #5F7F5F;">##           </span><span style="color: #7F9F7F;">monoling_e_3: {monoling_e_1}}</span>
<span style="color: #5F7F5F;">##</span>
<span style="color: #5F7F5F;">##   </span><span style="color: #7F9F7F;">means that (monoling_e_1 and monoling_e_2), and</span>
<span style="color: #5F7F5F;">##   </span><span style="color: #7F9F7F;">(monoling_e_1 and monoling_e_3) were translations of each other in a bidix.</span>

<span style="color: #DFAF8F;">WG_1</span> = {MONOLING_E_2: {MONOLING_E_3, MONOLING_E_4},
        MONOLING_E_3: {MONOLING_E_2},
        MONOLING_E_4: {MONOLING_E_2}}

<span style="color: #DFAF8F;">WG_2</span> = {MONOLING_E_2: {MONOLING_E_3, MONOLING_E_4},
        MONOLING_E_3: {MONOLING_E_2},
        MONOLING_E_4: {MONOLING_E_2, MONOLING_E_5},
        MONOLING_E_5: {MONOLING_E_4}}

<span style="color: #DFAF8F;">WG_3</span> = {MONOLING_E_6: {MONOLING_E_7, MONOLING_E_8, MONOLING_E_9},
        MONOLING_E_7: {MONOLING_E_6},
        MONOLING_E_8: {MONOLING_E_6},
        MONOLING_E_9: {MONOLING_E_6}}


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Functions</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">=========</span>

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">main</span>(main_bidix, iso_codes):
    <span style="color: #9FC59F;">""" String (List of String) -&gt; String</span>

<span style="color: #9FC59F;">    Given the path to the main bidix (read: biggest English-to-X or</span>
<span style="color: #9FC59F;">    X-to-English dictionary) and a list of iso3 codes of relevant languages,</span>
<span style="color: #9FC59F;">    construct a multidix, in which English words are linked to</span>
<span style="color: #9FC59F;">    their Wordnet definitions (in case of nouns, adjectives, verbs and</span>
<span style="color: #9FC59F;">    adverbs) and their translations to languages listed in iso_codes, and</span>
<span style="color: #9FC59F;">    return a string representation of that multidix (read: xml).</span>

<span style="color: #9FC59F;">    A word is considered a translation of the English word if there exists</span>
<span style="color: #9FC59F;">    a path between the two in the WordGraph constructed out of the bidixes.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #DFAF8F;">wg</span> = bidixes2wordgraph(
        append_leftiso3_rightiso3(
            get_bidixes(iso_codes)))

    <span style="color: #DFAF8F;">bidix</span> = ET.parse(main_bidix)
    <span style="color: #DFAF8F;">root</span> = bidix.getroot()
    <span style="color: #F0DFAF; font-weight: bold;">for</span> e <span style="color: #F0DFAF; font-weight: bold;">in</span> root.<span style="color: #DCDCCC; font-weight: bold;">iter</span>(<span style="color: #CC9393;">'e'</span>):
        <span style="color: #F0DFAF; font-weight: bold;">try</span>:
            <span style="color: #DFAF8F;">left</span>, <span style="color: #DFAF8F;">right</span> = pair2monolings(e[0], <span style="color: #CC9393;">'eng'</span>, <span style="color: #CC9393;">'kaz'</span>)
        <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">IndexError</span>:  <span style="color: #5F7F5F;"># </span><span style="color: #7F9F7F;">&lt;e&gt;&lt;re&gt;...&lt;/re&gt;&lt;p&gt;...&lt;/p&gt;</span>
            <span style="color: #DFAF8F;">left</span>, <span style="color: #DFAF8F;">right</span> = pair2monolings(e[1], <span style="color: #CC9393;">'eng'</span>, <span style="color: #CC9393;">'kaz'</span>)
        <span style="color: #F0DFAF; font-weight: bold;">if</span> left.lm <span style="color: #F0DFAF; font-weight: bold;">and</span> <span style="color: #DCDCCC; font-weight: bold;">len</span>(left.tags) &gt;= 1:
            <span style="color: #F0DFAF; font-weight: bold;">if</span> left.tags[0] <span style="color: #F0DFAF; font-weight: bold;">in</span> {<span style="color: #CC9393;">'n'</span>, <span style="color: #CC9393;">'v'</span>, <span style="color: #CC9393;">'adj'</span>, <span style="color: #CC9393;">'adv'</span>}:
                <span style="color: #F0DFAF; font-weight: bold;">for</span> defn <span style="color: #F0DFAF; font-weight: bold;">in</span> \
                  [synset.definition() <span style="color: #F0DFAF; font-weight: bold;">for</span> synset <span style="color: #F0DFAF; font-weight: bold;">in</span> \
                    wn.synsets(left.lm,
                               APERTIUMPOS_2_WNPOS[left.tags[0]])]:
                    <span style="color: #F0DFAF; font-weight: bold;">if</span> e.text:
                        <span style="color: #DFAF8F;">e.text</span> +=(defn + <span style="color: #CC9393;">'\n'</span>)
                    <span style="color: #F0DFAF; font-weight: bold;">else</span>:
                        <span style="color: #DFAF8F;">e.text</span> = defn + <span style="color: #CC9393;">'\n'</span>
        e.append(deepcopy(monolinge_2_iso3element(left)))
        e.append(deepcopy(monolinge_2_iso3element(right)))
        <span style="color: #F0DFAF; font-weight: bold;">for</span> monoling_e <span style="color: #F0DFAF; font-weight: bold;">in</span> wg_connections(wg, left):
            e.append(deepcopy(monolinge_2_iso3element(monoling_e)))
        <span style="color: #F0DFAF; font-weight: bold;">for</span> p <span style="color: #F0DFAF; font-weight: bold;">in</span> e.<span style="color: #DCDCCC; font-weight: bold;">iter</span>(<span style="color: #CC9393;">'p'</span>):
            e.remove(p)
 
    <span style="color: #F0DFAF; font-weight: bold;">return</span> minidom.parseString(ET.tostring(root)).toprettyxml(indent=<span style="color: #CC9393;">"  "</span>,
                                                              newl=<span style="color: #CC9393;">"\n"</span>)


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">manytags2singletag</span>(wg):
    <span style="color: #9FC59F;">""" WordGraph -&gt; WordGraph</span>

<span style="color: #9FC59F;">    Iterate through all nodes (= MonolingEntries) of wg and, if</span>
<span style="color: #9FC59F;">    a monolingentry.tags has many tags, limit it to a single tag</span>
<span style="color: #9FC59F;">    (part-of-speech tag).</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">_manytags2singletag</span>(me):
        <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC; font-weight: bold;">len</span>(me.tags) &gt; 1:
            <span style="color: #F0DFAF; font-weight: bold;">return</span> MonolingEntry(me.lang, me.lm, me.tags[:1])
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">return</span> me

    <span style="color: #DFAF8F;">res</span> = defaultdict(<span style="color: #DCDCCC; font-weight: bold;">set</span>)
    <span style="color: #F0DFAF; font-weight: bold;">for</span> me <span style="color: #F0DFAF; font-weight: bold;">in</span> wg:
        <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #DCDCCC; font-weight: bold;">len</span>(me.tags) &gt; 1:
            <span style="color: #F0DFAF; font-weight: bold;">for</span> neibr <span style="color: #F0DFAF; font-weight: bold;">in</span> wg[me]:
                res[_manytags2singletag(me)].add(_manytags2singletag(neibr))
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">for</span> neibr <span style="color: #F0DFAF; font-weight: bold;">in</span> wg[me]:
                res[me].add(_manytags2singletag(neibr))
    <span style="color: #F0DFAF; font-weight: bold;">return</span> res
 
<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_manytags2singletag</span>():
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> manytags2singletag(WG_3) == \
        {MonolingEntry(<span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"Moscow"</span>, (<span style="color: #CC9393;">"np"</span>,)):
            {MonolingEntry(<span style="color: #CC9393;">"tat"</span>, <span style="color: #CC9393;">"&#1052;&#1241;&#1089;&#1082;&#1241;&#1199;"</span>, (<span style="color: #CC9393;">"np"</span>,)),
             MonolingEntry(<span style="color: #CC9393;">"rus"</span>, <span style="color: #CC9393;">"&#1052;&#1086;&#1089;&#1082;&#1074;&#1072;"</span>, (<span style="color: #CC9393;">"np"</span>,)),
             MonolingEntry(<span style="color: #CC9393;">"tur"</span>, <span style="color: #CC9393;">"Moskova"</span>, ())},
         MonolingEntry(<span style="color: #CC9393;">"tat"</span>, <span style="color: #CC9393;">"&#1052;&#1241;&#1089;&#1082;&#1241;&#1199;"</span>, (<span style="color: #CC9393;">"np"</span>,)):
             {MonolingEntry(<span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"Moscow"</span>, (<span style="color: #CC9393;">"np"</span>,))},
         MonolingEntry(<span style="color: #CC9393;">"rus"</span>, <span style="color: #CC9393;">"&#1052;&#1086;&#1089;&#1082;&#1074;&#1072;"</span>, (<span style="color: #CC9393;">"np"</span>,)):
             {MonolingEntry(<span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"Moscow"</span>, (<span style="color: #CC9393;">"np"</span>,))},
         MonolingEntry(<span style="color: #CC9393;">"tur"</span>, <span style="color: #CC9393;">"Moskova"</span>, ()):
             {MonolingEntry(<span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"Moscow"</span>, (<span style="color: #CC9393;">"np"</span>,))}}


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">g_connections</span>(graph, start_node):
    <span style="color: #9FC59F;">""" Graph -&gt; (Generator Object)</span>

<span style="color: #9FC59F;">    Traverse the graph (avoiding cycles) starting with start_node and yield</span>
<span style="color: #9FC59F;">    all nodes the start node is connected to.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #DFAF8F;">frontier</span> = <span style="color: #DCDCCC; font-weight: bold;">set</span>()
    <span style="color: #DFAF8F;">seen</span> = {start_node}
    <span style="color: #F0DFAF; font-weight: bold;">for</span> neighbour <span style="color: #F0DFAF; font-weight: bold;">in</span> graph[start_node]:
        frontier.add(neighbour)
    <span style="color: #F0DFAF; font-weight: bold;">while</span> frontier:
        <span style="color: #DFAF8F;">current</span> = frontier.pop()
        <span style="color: #F0DFAF; font-weight: bold;">if</span> current <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> seen:
            <span style="color: #F0DFAF; font-weight: bold;">yield</span> current
            seen.add(current)
            <span style="color: #F0DFAF; font-weight: bold;">for</span> neighbour <span style="color: #F0DFAF; font-weight: bold;">in</span> graph[current]:
                frontier.add(neighbour)
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">continue</span>

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_g_connections</span>():
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #DCDCCC; font-weight: bold;">list</span>(g_connections(G_1, <span style="color: #CC9393;">'g'</span>)) == []
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #DCDCCC; font-weight: bold;">list</span>(g_connections(G_1, <span style="color: #CC9393;">'h'</span>)) == [<span style="color: #CC9393;">'i'</span>]
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #DCDCCC; font-weight: bold;">sorted</span>(g_connections(G_1, <span style="color: #CC9393;">'i'</span>)) == [<span style="color: #CC9393;">'h'</span>]
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #DCDCCC; font-weight: bold;">sorted</span>(g_connections(G_1, <span style="color: #CC9393;">'a'</span>)) == [<span style="color: #CC9393;">'b'</span>, <span style="color: #CC9393;">'c'</span>, <span style="color: #CC9393;">'d'</span>, <span style="color: #CC9393;">'f'</span>]
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #DCDCCC; font-weight: bold;">sorted</span>(g_connections(G_1, <span style="color: #CC9393;">'c'</span>)) == [<span style="color: #CC9393;">'a'</span>, <span style="color: #CC9393;">'b'</span>, <span style="color: #CC9393;">'d'</span>, <span style="color: #CC9393;">'f'</span>]


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">wg_connections</span>(graph, start_node):
    <span style="color: #9FC59F;">""" WordGraph -&gt; (Generator MonolingEntry)</span>

<span style="color: #9FC59F;">    Traverse the graph (avoiding cycles) starting with start_node and yield</span>
<span style="color: #9FC59F;">    all nodes the start node is connected to.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #DFAF8F;">frontier</span> = <span style="color: #DCDCCC; font-weight: bold;">set</span>()
    <span style="color: #DFAF8F;">seen</span> = {start_node.lang}
    <span style="color: #F0DFAF; font-weight: bold;">for</span> neighbour <span style="color: #F0DFAF; font-weight: bold;">in</span> graph[start_node]:
        frontier.add(neighbour)
    <span style="color: #F0DFAF; font-weight: bold;">while</span> frontier:
        <span style="color: #DFAF8F;">current</span> = frontier.pop()
        <span style="color: #F0DFAF; font-weight: bold;">if</span> current.lang <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> seen:
            <span style="color: #F0DFAF; font-weight: bold;">yield</span> current
            seen.add(current.lang)
            <span style="color: #F0DFAF; font-weight: bold;">for</span> neighbour <span style="color: #F0DFAF; font-weight: bold;">in</span> graph[current]:
                <span style="color: #F0DFAF; font-weight: bold;">if</span> neighbour.lang <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> seen:
                    frontier.add(neighbour)
        <span style="color: #F0DFAF; font-weight: bold;">else</span>:
            <span style="color: #F0DFAF; font-weight: bold;">continue</span>

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_wg_connections</span>():
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #DCDCCC; font-weight: bold;">sorted</span>(g_connections(WG_2, MONOLING_E_2)) ==\
           <span style="color: #DCDCCC; font-weight: bold;">sorted</span>([MONOLING_E_3,
                   MONOLING_E_4,
                   MONOLING_E_5])


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">bidixes2wordgraph</span>(bidixes):
    <span style="color: #9FC59F;">""" (List of (String, String, String) -&gt; WordGraph</span>

<span style="color: #9FC59F;">    Given a list of (bidix file name, lang1 iso3 code, lang 2 iso3 code)</span>
<span style="color: #9FC59F;">    tuples, return a WordGraph with all stems contained in those bidix files.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #DFAF8F;">res</span> = defaultdict(<span style="color: #DCDCCC; font-weight: bold;">set</span>)
    <span style="color: #F0DFAF; font-weight: bold;">for</span> bidix, left_lang, right_lang <span style="color: #F0DFAF; font-weight: bold;">in</span> bidixes:
        <span style="color: #F0DFAF; font-weight: bold;">try</span>:
            <span style="color: #DFAF8F;">bidix_root</span> = ET.parse(bidix).getroot()
        <span style="color: #F0DFAF; font-weight: bold;">except</span> ET.ParseError:
            <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">"Couldn't parse "</span>, bidix, <span style="color: #CC9393;">". Ill-formed xml?"</span>,
                  <span style="color: #DCDCCC; font-weight: bold;">file</span>=sys.stderr)
            <span style="color: #F0DFAF; font-weight: bold;">continue</span>
        <span style="color: #F0DFAF; font-weight: bold;">for</span> pair <span style="color: #F0DFAF; font-weight: bold;">in</span> bidix_root.<span style="color: #DCDCCC; font-weight: bold;">iter</span>(<span style="color: #CC9393;">'p'</span>):
            <span style="color: #DFAF8F;">left</span>, <span style="color: #DFAF8F;">right</span> = pair2monolings(pair, left_lang, right_lang)
            res[left].add(right)
            res[right].add(left)
    <span style="color: #F0DFAF; font-weight: bold;">return</span> res

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_bidixes2wordgraph</span>():
    <span style="color: #DFAF8F;">eng_kaz</span> = StringIO(u<span style="color: #CC9393;">"""&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span style="color: #CC9393;">                     &lt;dictionary&gt;</span>
<span style="color: #CC9393;">                       &lt;alphabet&gt;&lt;/alphabet&gt;</span>
<span style="color: #CC9393;">                       &lt;sdefs&gt;</span>
<span style="color: #CC9393;">                         &lt;sdef n="n"               c="Noun"/&gt;</span>
<span style="color: #CC9393;">                       &lt;/sdefs&gt;</span>

<span style="color: #CC9393;">                       &lt;section id="main" type="standard"&gt;</span>
<span style="color: #CC9393;">                         &lt;e&gt;&lt;p&gt;&lt;l&gt;file&lt;s n="n"/&gt;&lt;/l&gt;&lt;r&gt;&#1092;&#1072;&#1081;&#1083;&lt;s n="n"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;</span>
<span style="color: #CC9393;">                         &lt;e&gt;&lt;p&gt;&lt;l&gt;file&lt;s n="n"/&gt;&lt;/l&gt;&lt;r&gt;&#1077;&#1075;&#1077;&#1091;&lt;s n="n"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;</span>
<span style="color: #CC9393;">                       &lt;/section&gt;</span>
<span style="color: #CC9393;">                     &lt;/dictionary&gt;"""</span>)
    <span style="color: #DFAF8F;">kaz_tat</span> = StringIO(u<span style="color: #CC9393;">"""&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span style="color: #CC9393;">                     &lt;dictionary&gt;</span>
<span style="color: #CC9393;">                       &lt;alphabet&gt;&lt;/alphabet&gt;</span>
<span style="color: #CC9393;">                       &lt;sdefs&gt;</span>
<span style="color: #CC9393;">                         &lt;sdef n="n"               c="Noun"/&gt;</span>
<span style="color: #CC9393;">                       &lt;/sdefs&gt;</span>

<span style="color: #CC9393;">                       &lt;section id="main" type="standard"&gt;</span>
<span style="color: #CC9393;">                         &lt;e&gt;&lt;p&gt;&lt;l&gt;&#1077;&#1075;&#1077;&#1091;&lt;s n="n"/&gt;&lt;/l&gt;&lt;r&gt;&#1080;&#1075;&#1241;&#1199;&lt;s n="n"/&gt;&lt;/r&gt;&lt;/p&gt;&lt;/e&gt;</span>
<span style="color: #CC9393;">                       &lt;/section&gt;</span>
<span style="color: #CC9393;">                     &lt;/dictionary&gt;"""</span>)

    <span style="color: #F0DFAF; font-weight: bold;">assert</span> bidixes2wordgraph([(eng_kaz, <span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"kaz"</span>),
                              (kaz_tat, <span style="color: #CC9393;">"kaz"</span>, <span style="color: #CC9393;">"tat"</span>)]) == WG_2


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">pair2monolings</span>(pair, left_lang, right_lang):
    <span style="color: #9FC59F;">""" ElementTree.Element String String -&gt; (MonolingEntry, MonolingEntry)</span>

<span style="color: #9FC59F;">    Extract the &lt;l&gt;eft and &lt;r&gt;ight hand sides from a &lt;p&gt;air element.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> MonolingEntry(left_lang,
                         <span style="color: #CC9393;">' '</span>.join(pair[0].itertext()),
                         <span style="color: #DCDCCC; font-weight: bold;">tuple</span>(s.attrib[<span style="color: #CC9393;">'n'</span>] <span style="color: #F0DFAF; font-weight: bold;">for</span> s <span style="color: #F0DFAF; font-weight: bold;">in</span> pair[0].<span style="color: #DCDCCC; font-weight: bold;">iter</span>(<span style="color: #CC9393;">'s'</span>))), \
           MonolingEntry(right_lang,
                         <span style="color: #CC9393;">' '</span>.join(pair[1].itertext()),
                         <span style="color: #DCDCCC; font-weight: bold;">tuple</span>(s.attrib[<span style="color: #CC9393;">'n'</span>] <span style="color: #F0DFAF; font-weight: bold;">for</span> s <span style="color: #F0DFAF; font-weight: bold;">in</span> pair[1].<span style="color: #DCDCCC; font-weight: bold;">iter</span>(<span style="color: #CC9393;">'s'</span>)))

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_pair2monolings</span>():
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> pair2monolings(ET.fromstring(<span style="color: #CC9393;">"""&lt;p&gt;&lt;l&gt;file&lt;s n="n"/&gt;&lt;/l&gt;&lt;r&gt;&#1092;&#1072;&#1081;&#1083;&lt;s n="n"/&gt;&lt;/r&gt;&lt;/p&gt;"""</span>), <span style="color: #CC9393;">"eng"</span>, <span style="color: #CC9393;">"kaz"</span>) == \
           (MONOLING_E_2, MONOLING_E_3)


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">monolinge_2_iso3element</span>(monoling_e):
    <span style="color: #9FC59F;">""" MonolingEntry -&gt; ElementTree.Element</span>

<span style="color: #9FC59F;">    Convert the given monolingual entry into a xml element to be put</span>
<span style="color: #9FC59F;">    inside of &lt;e&gt; in the final multidix.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #DFAF8F;">res</span> = ET.Element(monoling_e.lang)
    <span style="color: #DFAF8F;">res.text</span> = monoling_e.lm
    <span style="color: #F0DFAF; font-weight: bold;">for</span> tag <span style="color: #F0DFAF; font-weight: bold;">in</span> monoling_e.tags:
        ET.SubElement(res, <span style="color: #CC9393;">'s'</span>, {<span style="color: #CC9393;">'n'</span>: tag})
    <span style="color: #F0DFAF; font-weight: bold;">return</span> res

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_monolinge_2_iso3element</span>():
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> ET.tostring(monolinge_2_iso3element(MONOLING_E_1),
                       encoding=<span style="color: #CC9393;">"unicode"</span>) == <span style="color: #CC9393;">"&lt;eng /&gt;"</span>
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> ET.tostring(monolinge_2_iso3element(MONOLING_E_6),
                       encoding=<span style="color: #CC9393;">"unicode"</span>) == \
           <span style="color: #CC9393;">"""&lt;eng&gt;Moscow&lt;s n="np" /&gt;&lt;s n="top" /&gt;&lt;/eng&gt;"""</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">append_leftiso3_rightiso3</span>(bidixes):
    <span style="color: #9FC59F;">""" (List of String) -&gt; (List of (String, String, String))</span>

<span style="color: #9FC59F;">    Given a list with the names of bidix files, extract the language names</span>
<span style="color: #9FC59F;">    and return a list with (bidix file name, lang1 iso3 code, lang2 iso3 code)</span>
<span style="color: #9FC59F;">    tuples.</span>
<span style="color: #9FC59F;">    ASSUME: bidix files are named following the standard:</span>
<span style="color: #9FC59F;">            apertium-iso2or3-iso2or3.iso2or3-iso2or3.dix</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #DFAF8F;">res</span> = []
    <span style="color: #F0DFAF; font-weight: bold;">for</span> bidix <span style="color: #F0DFAF; font-weight: bold;">in</span> bidixes:
        <span style="color: #F0DFAF; font-weight: bold;">try</span>:
            <span style="color: #DFAF8F;">parse</span> = re.search(r<span style="color: #CC9393;">'.*apertium-([^-]+)-([^-]+).\1-\2.dix'</span>, bidix)
            <span style="color: #DFAF8F;">lang1_iso3</span> = ISO2_2_ISO3.get(parse.group(1), parse.group(1))
            <span style="color: #DFAF8F;">lang2_iso3</span> = ISO2_2_ISO3.get(parse.group(2), parse.group(2))
            res.append((bidix, lang1_iso3, lang2_iso3))
        <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">AttributeError</span>:
            <span style="color: #F0DFAF; font-weight: bold;">raise</span> <span style="color: #7CB8BB;">ValueError</span>(<span style="color: #CC9393;">"Couldn't figure out the source language and "</span>
                             <span style="color: #CC9393;">"target language's iso codes from the bidix name!"</span>)
    <span style="color: #F0DFAF; font-weight: bold;">return</span> res

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_append_leftiso3_rightiso3</span>():
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> append_leftiso3_rightiso3([<span style="color: #CC9393;">'../apertium-kaz-tat.kaz-tat.dix'</span>,
                                      <span style="color: #CC9393;">'/home/foo/apertium-tt-ky.tt-ky.dix'</span>,
                                      <span style="color: #CC9393;">'apertium-ug-kaz.ug-kaz.dix'</span>]) == \
           [(<span style="color: #CC9393;">'../apertium-kaz-tat.kaz-tat.dix'</span>, <span style="color: #CC9393;">'kaz'</span>, <span style="color: #CC9393;">'tat'</span>),
            (<span style="color: #CC9393;">'/home/foo/apertium-tt-ky.tt-ky.dix'</span>, <span style="color: #CC9393;">'tat'</span>, <span style="color: #CC9393;">'kir'</span>),
            (<span style="color: #CC9393;">'apertium-ug-kaz.ug-kaz.dix'</span>, <span style="color: #CC9393;">'uig'</span>, <span style="color: #CC9393;">'kaz'</span>)]


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">get_bidixes</span>(apertium_root, skip_folders, iso_codes):
    <span style="color: #9FC59F;">""" String (List of String) (List of String) -&gt; (List of String)</span>

<span style="color: #9FC59F;">    Return the paths to all bidixes in apertium_root repo, in which both sl and</span>
<span style="color: #9FC59F;">    tl are a language in iso_codes (except for bidixes in skip_folders)</span>
<span style="color: #9FC59F;">    """</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">is_skippable</span>(filepath):
        <span style="color: #9FC59F;">""" String -&gt; Boolean</span>

<span style="color: #9FC59F;">        Given a path to a bidix file, return True if it is located in</span>
<span style="color: #9FC59F;">        a folder which should be skipped (code in branches/,release/ or similar).</span>
<span style="color: #9FC59F;">        """</span>
        <span style="color: #F0DFAF; font-weight: bold;">for</span> f <span style="color: #F0DFAF; font-weight: bold;">in</span> skip_folders:
            <span style="color: #F0DFAF; font-weight: bold;">if</span> f <span style="color: #F0DFAF; font-weight: bold;">in</span> filepath:
                <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">True</span>
        <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #BFEBBF;">False</span>

    <span style="color: #DFAF8F;">res</span> = []
    <span style="color: #F0DFAF; font-weight: bold;">for</span> filename <span style="color: #F0DFAF; font-weight: bold;">in</span> glob.iglob(apertium_root + <span style="color: #CC9393;">'**/*.dix'</span>, recursive=<span style="color: #BFEBBF;">True</span>):
        <span style="color: #F0DFAF; font-weight: bold;">if</span> <span style="color: #F0DFAF; font-weight: bold;">not</span> is_skippable(filename):
            <span style="color: #DFAF8F;">basename</span> = os.path.basename(filename)
            <span style="color: #F0DFAF; font-weight: bold;">for</span> frst_iso <span style="color: #F0DFAF; font-weight: bold;">in</span> iso_codes:
                <span style="color: #F0DFAF; font-weight: bold;">for</span> scnd_iso <span style="color: #F0DFAF; font-weight: bold;">in</span> iso_codes:
                    <span style="color: #F0DFAF; font-weight: bold;">if</span> basename == <span style="color: #CC9393;">"apertium-{0}-{1}.{0}-{1}.dix"</span>.<span style="color: #DCDCCC; font-weight: bold;">format</span>(frst_iso,
                                                                         scnd_iso):
                        res.append(filename)
    <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'\n'</span>.join(res), <span style="color: #DCDCCC; font-weight: bold;">file</span>=sys.stderr)
    <span style="color: #F0DFAF; font-weight: bold;">return</span> res


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Formatters</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">----------</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">wordgraph2sexp</span>(wg):
    <span style="color: #9FC59F;">""" WordGraph -&gt; String</span>

<span style="color: #9FC59F;">    Return s-expression representation of wg.</span>
<span style="color: #9FC59F;">    """</span>

    <span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">me2sexp</span>(me):
        <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #CC9393;">'('</span> + me.lang + <span style="color: #CC9393;">' "'</span> + me.lm + <span style="color: #CC9393;">'" ('</span> + \
               <span style="color: #CC9393;">' '</span>.join(me.tags) + <span style="color: #CC9393;">'))'</span>

    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #CC9393;">'('</span> + <span style="color: #CC9393;">'\n '</span>.join(me2sexp(k) + \
                           <span style="color: #CC9393;">' ('</span> + \
                           <span style="color: #CC9393;">' '</span>.join(me2sexp(n) <span style="color: #F0DFAF; font-weight: bold;">for</span> n <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">sorted</span>(<span style="color: #DCDCCC; font-weight: bold;">list</span>(v))) + \
                           <span style="color: #CC9393;">')'</span> \
                           <span style="color: #F0DFAF; font-weight: bold;">for</span> k, v <span style="color: #F0DFAF; font-weight: bold;">in</span> wg.items()) + \
           <span style="color: #CC9393;">')'</span>

<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">test_wordgraph2sexp</span>():
    <span style="color: #DFAF8F;">expected</span> = \
    <span style="color: #CC9393;">"""</span>
<span style="color: #CC9393;">    ((eng "file" (n)) ((kaz "&#1077;&#1075;&#1077;&#1091;" (n))</span>
<span style="color: #CC9393;">                       (kaz "&#1092;&#1072;&#1081;&#1083;" (n)))</span>
<span style="color: #CC9393;">     (kaz "&#1092;&#1072;&#1081;&#1083;" (n)) ((eng "file" (n)))</span>
<span style="color: #CC9393;">     (kaz "&#1077;&#1075;&#1077;&#1091;" (n)) ((eng "file" (n))))</span>
<span style="color: #CC9393;">    """</span>
    <span style="color: #F0DFAF; font-weight: bold;">assert</span> <span style="color: #CC9393;">" "</span>.join(wordgraph2sexp(WG_1).split()) == <span style="color: #CC9393;">" "</span>.join(expected.split())


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Runner</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">======</span>

<span style="color: #5F7F5F;">#    </span><span style="color: #7F9F7F;">print(main(MAIN_BIDIX, RELEVANT_ISOS))</span>

</pre>
</div>
</div>
</div>

<div id="outline-container-org4579c8d" class="outline-6">
<h6 id="org4579c8d"><span class="section-number-6">4.1.1.5.2</span> A script for converting English Wordnet leammas into Turkic languages</h6>
<div class="outline-text-6" id="text-4-1-1-5-2">
<div class="org-src-container">
<pre class="src src-python" id="orgf058c15">
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">enwordnet2wordnet.py</span>
<span style="color: #5F7F5F;">##</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">A script which walks over the synsets in the English Wordnet and prints</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">translations for each English lemma in each synset using Google Translate</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">(gt), Yandex Translate (yt) and looking them up in Apertium (ap) bilingual</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">dictionaries (turned into a multilingual word graph beforehand).</span>
<span style="color: #5F7F5F;">##</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">USAGE: python3 enwordnet2twordnet.py</span>
<span style="color: #5F7F5F;">##</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">A snippet from the current output:</span>
<span style="color: #5F7F5F;">##</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">def: (botany) a living organism lacking the power of locomotion</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">ex: []</span>
<span style="color: #5F7F5F;">##     </span><span style="color: #7F9F7F;">eng: plant</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">aze-gt: bitki?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">aze-yt: zavod?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">bak-yt: &#1079;&#1072;&#1074;&#1086;&#1076;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-ap: &#1082;&#1241;&#1089;&#1110;&#1087;&#1086;&#1088;&#1099;&#1085;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-ap: &#1257;&#1089;&#1110;&#1084;&#1076;&#1110;&#1082;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-ap: &#1092;&#1072;&#1073;&#1088;&#1080;&#1082;&#1072;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-ap: &#1079;&#1072;&#1091;&#1099;&#1090;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-ap: &#1179;&#1086;&#1085;&#1076;&#1099;&#1088;&#1171;&#1099;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-ap: &#1082;&#1257;&#1096;&#1077;&#1090;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-gt: &#1257;&#1089;&#1110;&#1084;&#1076;&#1110;&#1082;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-yt: &#1079;&#1072;&#1091;&#1099;&#1090;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kir-gt: &#1257;&#1089;&#1199;&#1084;&#1076;&#1199;&#1082;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kir-yt: &#1079;&#1072;&#1074;&#1086;&#1076;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tat-ap: &#1082;&#1086;&#1084;&#1073;&#1080;&#1085;&#1072;&#1090;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tat-ap: &#1199;&#1089;&#1077;&#1084;&#1083;&#1077;&#1082;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tat-ap: &#1079;&#1072;&#1074;&#1086;&#1076;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tat-yt: &#1079;&#1072;&#1074;&#1086;&#1076;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tur-gt: bitki?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tur-yt: bitki?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">uzb-gt: o&amp;#39;simlik?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">uzb-yt: o'simlik?</span>
<span style="color: #5F7F5F;">##     </span><span style="color: #7F9F7F;">eng: flora</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">aze-gt: flora?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">aze-yt: Flora?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">bak-yt: &#1060;&#1083;&#1086;&#1088;&#1072;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-ap: &#1092;&#1083;&#1086;&#1088;&#1072;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-gt: &#1257;&#1089;&#1110;&#1084;&#1076;&#1110;&#1082;&#1090;&#1077;&#1088;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-yt: &#1060;&#1083;&#1086;&#1088;&#1072;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kir-gt: &#1257;&#1089;&#1199;&#1084;&#1076;&#1199;&#1082;&#1090;&#1257;&#1088;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kir-yt: &#1060;&#1083;&#1086;&#1088;&#1072;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tat-ap: &#1092;&#1083;&#1086;&#1088;&#1072;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tat-yt: &#1060;&#1083;&#1086;&#1088;&#1072;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tur-gt: bitki &#246;rt&#252;s&#252;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tur-yt: flora?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">uzb-gt: flora?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">uzb-yt: o'simlik?</span>
<span style="color: #5F7F5F;">##     </span><span style="color: #7F9F7F;">eng: plant life</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">aze-gt: bitki h&#601;yt&#305;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">aze-yt: h&#601;yt bitkil&#601;r ?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">bak-yt: &#1199;&#1195;&#1077;&#1084;&#1083;&#1077;&#1082;&#1090;&#1241;&#1088; &#1090;&#1086;&#1088;&#1084;&#1086;&#1096;&#1086; ?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-gt: &#1256;&#1089;&#1110;&#1084;&#1076;&#1110;&#1082;&#1090;&#1077;&#1088;&#1076;&#1110;&#1187; &#1257;&#1084;&#1110;&#1088;&#1110;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kaz-yt: &#1257;&#1089;&#1110;&#1084;&#1076;&#1110;&#1082;&#1090;&#1077;&#1088;&#1076;&#1110;&#1187; &#1257;&#1084;&#1110;&#1088;&#1110; ?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kir-gt: &#1257;&#1089;&#1199;&#1084;&#1076;&#1199;&#1082;&#1090;&#1257;&#1088;&#1076;&#1199;&#1085; &#1078;&#1072;&#1096;&#1086;&#1086;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">kir-yt: &#1072;&#1082;-&#1257;&#1089;&#1199;&#1084;&#1076;&#1199;&#1082;&#1090;&#1257;&#1088;&#1076;&#1199;&#1085; ?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tat-yt: &#1090;&#1086;&#1088;&#1084;&#1099;&#1096; &#1199;&#1089;&#1077;&#1084;&#1083;&#1077;&#1082;&#1083;&#1241;&#1088; ?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tur-gt: bitki hayt&#305;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">tur-yt: bitki ya&#351;am&#305;?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">uzb-gt: o&amp;#39;simlik hayoti?</span>
<span style="color: #5F7F5F;">##         </span><span style="color: #7F9F7F;">uzb-yt: o'simlik hayoti?</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">&lt;...&gt;</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Full output is in the xnet/ folder.</span>

<span style="color: #F0DFAF; font-weight: bold;">import</span> nltk
nltk.data.path.append(r<span style="color: #CC9393;">"/home/selimcan/local/nltk_data"</span>)
<span style="color: #F0DFAF; font-weight: bold;">from</span> nltk.corpus <span style="color: #F0DFAF; font-weight: bold;">import</span> wordnet <span style="color: #F0DFAF; font-weight: bold;">as</span> wn
<span style="color: #F0DFAF; font-weight: bold;">from</span> yandex_translate <span style="color: #F0DFAF; font-weight: bold;">import</span> YandexTranslate  <span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">pip install yandex.translate</span>
<span style="color: #F0DFAF; font-weight: bold;">from</span> googleapiclient.discovery <span style="color: #F0DFAF; font-weight: bold;">import</span> build

<span style="color: #F0DFAF; font-weight: bold;">import</span> wordgraph <span style="color: #F0DFAF; font-weight: bold;">as</span> wg


<span style="color: #5F7F5F;">############</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Constants</span>


<span style="color: #DFAF8F;">APERTIUM_ROOT</span> = <span style="color: #CC9393;">'../apertium-all/'</span>

<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">from here: http://wiki.apertium.org/wiki/Turkic-languages</span>
<span style="color: #DFAF8F;">RELEVANT_ISOS</span> =  [<span style="color: #CC9393;">'kaz'</span>, <span style="color: #CC9393;">'kz'</span>, <span style="color: #CC9393;">'tat'</span>, <span style="color: #CC9393;">'tt'</span>, <span style="color: #CC9393;">'kir'</span>, <span style="color: #CC9393;">'ky'</span>, <span style="color: #CC9393;">'tyv'</span>, <span style="color: #CC9393;">'tur'</span>, <span style="color: #CC9393;">'tr'</span>,
                  <span style="color: #CC9393;">'chv'</span>, <span style="color: #CC9393;">'cv'</span>, <span style="color: #CC9393;">'kum'</span>, <span style="color: #CC9393;">'kaa'</span>, <span style="color: #CC9393;">'uzb'</span>, <span style="color: #CC9393;">'uz'</span>, <span style="color: #CC9393;">'sah'</span>, <span style="color: #CC9393;">'crh'</span>, <span style="color: #CC9393;">'krc'</span>,
                  <span style="color: #CC9393;">'bak'</span>, <span style="color: #CC9393;">'ba'</span>, <span style="color: #CC9393;">'nog'</span>, <span style="color: #CC9393;">'gag'</span>, <span style="color: #CC9393;">'tuk'</span>, <span style="color: #CC9393;">'tk'</span>, <span style="color: #CC9393;">'uig'</span>, <span style="color: #CC9393;">'ug'</span>, <span style="color: #CC9393;">'kjh'</span>,
                  <span style="color: #CC9393;">'ota'</span>, <span style="color: #CC9393;">'aze'</span>, <span style="color: #CC9393;">'az'</span>, <span style="color: #CC9393;">'eng'</span>, <span style="color: #CC9393;">'en'</span>]

<span style="color: #DFAF8F;">SKIP_FOLDERS</span> = [<span style="color: #CC9393;">'release'</span>, <span style="color: #CC9393;">'branches'</span>]  <span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">only relevant for the old svn repo</span>

<span style="color: #DFAF8F;">MAIN_BIDIX</span> = APERTIUM_ROOT + \
             <span style="color: #CC9393;">'apertium-trunk/apertium-eng-kaz/apertium-eng-kaz.eng-kaz.dix'</span>

<span style="color: #DFAF8F;">APERTIUMPOS_2_WNPOS</span> = {<span style="color: #CC9393;">'n'</span>: wn.NOUN, <span style="color: #CC9393;">'v'</span>: wn.VERB, <span style="color: #CC9393;">'adj'</span>: wn.ADJ, <span style="color: #CC9393;">'adv'</span>: wn.ADV}

<span style="color: #DFAF8F;">POS</span> = <span style="color: #CC9393;">'n'</span>

<span style="color: #DFAF8F;">GT_API_KEY</span> = <span style="color: #CC9393;">'get one yourself if you need to'</span>

<span style="color: #DFAF8F;">GT</span> = build(<span style="color: #CC9393;">'translate'</span>, <span style="color: #CC9393;">'v2'</span>, developerKey=GT_API_KEY)

<span style="color: #DFAF8F;">YAT_API_KEY</span> = <span style="color: #CC9393;">'get one yourself if you need to'</span>

<span style="color: #DFAF8F;">YAT</span> = YandexTranslate(YAT_API_KEY)

<span style="color: #DFAF8F;">AWG</span> = wg.manytags2singletag(
          wg.bidixes2wordgraph(
              wg.append_leftiso3_rightiso3(
                  wg.get_bidixes(APERTIUM_ROOT, SKIP_FOLDERS, RELEVANT_ISOS))))

<span style="color: #DFAF8F;">TURKIC</span> = [<span style="color: #CC9393;">'alt'</span>, <span style="color: #CC9393;">'aze'</span>, <span style="color: #CC9393;">'bak'</span>, <span style="color: #CC9393;">'chv'</span>, <span style="color: #CC9393;">'crh'</span>, <span style="color: #CC9393;">'gag'</span>, <span style="color: #CC9393;">'kaa'</span>, <span style="color: #CC9393;">'kaz'</span>, <span style="color: #CC9393;">'kir'</span>, <span style="color: #CC9393;">'kjh'</span>,
          <span style="color: #CC9393;">'krc'</span>, <span style="color: #CC9393;">'kum'</span>, <span style="color: #CC9393;">'nog'</span>, <span style="color: #CC9393;">'ota'</span>, <span style="color: #CC9393;">'sah'</span>, <span style="color: #CC9393;">'tat'</span>, <span style="color: #CC9393;">'tuk'</span>, <span style="color: #CC9393;">'tur'</span>, <span style="color: #CC9393;">'tyv'</span>, <span style="color: #CC9393;">'uig'</span>,
          <span style="color: #CC9393;">'uzb'</span>]

<span style="color: #DFAF8F;">TURKIC_IN_GT</span> = {<span style="color: #CC9393;">'aze'</span>,<span style="color: #CC9393;">'kaz'</span>, <span style="color: #CC9393;">'kir'</span>, <span style="color: #CC9393;">'tur'</span>, <span style="color: #CC9393;">'uzb'</span>}

<span style="color: #DFAF8F;">TURKIC_IN_YAT</span> = {<span style="color: #CC9393;">'aze'</span>, <span style="color: #CC9393;">'bak'</span>, <span style="color: #CC9393;">'kaz'</span>, <span style="color: #CC9393;">'kir'</span>, <span style="color: #CC9393;">'tat'</span>, <span style="color: #CC9393;">'tur'</span>, <span style="color: #CC9393;">'uzb'</span>}


<span style="color: #5F7F5F;">############</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Functions</span>


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">yat_translate</span>(s, lang1, lang2):
    <span style="color: #9FC59F;">""" (String String String) -&gt; String</span>

<span style="color: #9FC59F;">    Translate lang1 string s to lang2 with Yandex Translate.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> <span style="color: #CC9393;">' '</span>.join(YAT.translate(s, lang1 + <span style="color: #CC9393;">'-'</span> + lang2)[<span style="color: #CC9393;">'text'</span>])


<span style="color: #F0DFAF; font-weight: bold;">def</span> <span style="color: #93E0E3;">gt_translate</span>(s, lang1, lang2):
    <span style="color: #9FC59F;">""" (String String String) -&gt; String</span>

<span style="color: #9FC59F;">    Translate lang1 string s to lang2 with Google Translate.</span>
<span style="color: #9FC59F;">    """</span>
    <span style="color: #F0DFAF; font-weight: bold;">return</span> GT.translations().<span style="color: #DCDCCC; font-weight: bold;">list</span>(source=lang1,
                                  target=lang2, q=s).execute()[<span style="color: #CC9393;">'translations'</span>][0][<span style="color: #CC9393;">'translatedText'</span>]


<span style="color: #5F7F5F;">#########</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Runner</span>


<span style="color: #F0DFAF; font-weight: bold;">for</span> s <span style="color: #F0DFAF; font-weight: bold;">in</span> <span style="color: #DCDCCC; font-weight: bold;">list</span>(wn.all_synsets(POS))[:10]:
    <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'def:'</span>, s.definition())
    <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'ex:'</span>, s.examples())
    <span style="color: #F0DFAF; font-weight: bold;">for</span> l <span style="color: #F0DFAF; font-weight: bold;">in</span> s.lemmas():
        <span style="color: #DFAF8F;">l</span> = l.name().replace(<span style="color: #CC9393;">'_'</span>, <span style="color: #CC9393;">' '</span>)
        <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'    eng:'</span>, l)
        <span style="color: #F0DFAF; font-weight: bold;">for</span> lang <span style="color: #F0DFAF; font-weight: bold;">in</span> TURKIC:
            <span style="color: #DFAF8F;">seen</span> = <span style="color: #DCDCCC; font-weight: bold;">set</span>()
            <span style="color: #F0DFAF; font-weight: bold;">try</span>:
                <span style="color: #DFAF8F;">nbrs</span> = AWG[wg.MonolingEntry(<span style="color: #CC9393;">'eng'</span>, l, (POS,))]
                <span style="color: #F0DFAF; font-weight: bold;">for</span> n <span style="color: #F0DFAF; font-weight: bold;">in</span> nbrs:
                    <span style="color: #F0DFAF; font-weight: bold;">if</span> n.lang == lang <span style="color: #F0DFAF; font-weight: bold;">and</span> n.lm <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> seen:
                        <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'        '</span> + lang + <span style="color: #CC9393;">'-ap:'</span>, n.lm + <span style="color: #CC9393;">'?'</span>)
                        seen.add(n.lm)
            <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">KeyError</span>:
                <span style="color: #F0DFAF; font-weight: bold;">try</span>:
                    <span style="color: #DFAF8F;">nbrs</span> = AWG[wg.MonolingEntry(<span style="color: #CC9393;">'eng'</span>, l, ())]
                    <span style="color: #F0DFAF; font-weight: bold;">for</span> n <span style="color: #F0DFAF; font-weight: bold;">in</span> nbrs:
                        <span style="color: #F0DFAF; font-weight: bold;">if</span> n.lang == lang <span style="color: #F0DFAF; font-weight: bold;">and</span> n.lm <span style="color: #F0DFAF; font-weight: bold;">not</span> <span style="color: #F0DFAF; font-weight: bold;">in</span> seen:
                            <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'        '</span> + lang + <span style="color: #CC9393;">'-ap:'</span>, n.lm + <span style="color: #CC9393;">'?'</span>)
                            seen.add(n.lm)
                <span style="color: #F0DFAF; font-weight: bold;">except</span> <span style="color: #7CB8BB;">KeyError</span>:
                    <span style="color: #F0DFAF; font-weight: bold;">pass</span>
            <span style="color: #F0DFAF; font-weight: bold;">if</span> lang <span style="color: #F0DFAF; font-weight: bold;">in</span> TURKIC_IN_GT:
                <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'        '</span> + lang + <span style="color: #CC9393;">'-gt:'</span>,
                      gt_translate(l, <span style="color: #CC9393;">'eng'</span>, lang) + <span style="color: #CC9393;">'?'</span>)
            <span style="color: #F0DFAF; font-weight: bold;">if</span> lang <span style="color: #F0DFAF; font-weight: bold;">in</span> TURKIC_IN_YAT:
                <span style="color: #F0DFAF; font-weight: bold;">print</span>(<span style="color: #CC9393;">'        '</span> + lang + <span style="color: #CC9393;">'-yat:'</span>,
                      yat_translate(l, <span style="color: #CC9393;">'en'</span>, wg.ISO3_2_ISO2[lang]) + <span style="color: #CC9393;">'?'</span>)

</pre>
</div>

<p>
Putting it into action:
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orge71ff2b" class="outline-4">
<h4 id="orge71ff2b"><span class="section-number-4">4.1.2</span> Parallel corpus</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
Conditions:
</p>

<ul class="org-ul">
<li>already available for the max. number of Turkic languages</li>
<li>free license</li>
<li>contemporary language</li>
</ul>

<p>
Options:
</p>

<ul class="org-ul">
<li>Bible.
<ul class="org-ul">
<li>Currently <a href="https://github.com/taruen/apertiumpp/tree/master/data4apertium/corpora/bible">we have</a> New Testaments in alt, chv, crh, kaa, kaz, kir, kjh,
krc, kum, nog, sah, tat, tyv, uzb.</li>
<li>TODO scrape ibt.org.ru and gospelgo and add tur, bak, gag, tuk, uig, ota?
and aze translations of the Bible/New Testament in the <a href="http://wiki.apertium.org/wiki/Bible_corpora">standard format</a>.</li>
<li>TODO if the process did not require any manual correction, get Bible/NT
translations for all languages / all languages currently present in
Apertium, otherwise mark this todo as a :GCI: task</li>
</ul></li>

<li>Quran. Available in
<ul class="org-ul">
<li>kaz (from kuran.kz; in turkiccorpora;
<ul class="org-ul">
<li>TODO contact authors &#x2013; sharing on tanzil.net? (via Tanzil it will end up
in OPUS)</li>
<li>TODO reformat to conform tanzil format if the answer is yes)</li>
</ul></li>
<li>tat (in turkiccorpora; few other not OCR'd)</li>
<li>kir (TODO add to turkiccorpora; available <a href="http://www.quran-ebook.com/">here</a> and <a href="https://archive.org/details/TranslationOfTheMeaningOfTheNobleQuranInTheKYRGYZKIRGHIZLanguageHQ">here</a>) :GCI:</li>
<li>tyv?</li>
<li>tur * 10 (TODO add to turkiccorpora; available on tanzil.net)</li>
<li>chv (yes, but couldn't find online. Available upon request in electronic
for, the author of it says in an interview)</li>
<li>kum?</li>
<li>kaa?</li>
<li>uzb (TODO add to turkiccorpora; available on tanzil.net)</li>
<li>sah?</li>
<li>crh (TODO add to turkiccorpora; available <a href="http://crimean.org/islam/koran/dizen-qurtnezir">here</a>) :GCI:</li>
<li>krc (TODO convert to plain text; available in: turkiccorpora/dev) :GCI:</li>
<li>bak (TODO convert to plain text; available in: turkiccorpora/dev) :GCI:</li>
<li>nog?</li>
<li>gag?</li>
<li>tuk (yes, but couldn't find online)</li>
<li>uig (TODO add to turkiccorpora; available on tanzil.net)</li>
<li>kjh?</li>
<li>ota (probably not OCR'd)</li>
<li>aze * 2 (TODO add to turkiccorpora; available on tanzil.net) :GCI:</li>
</ul></li>

<li><a href="https://www.unicode.org/udhr/translations.html">Universal Declaration of Human Rights</a>. Available in 520 languages as of
19.04.2019. Pretty small (~1500 words), but a good alternative or complement
for the 'James and Mary' story because of the social value of this document.</li>
</ul>

<p>
Also see:
</p>

<ul class="org-ul">
<li><a href="http://wiki.apertium.org/wiki/Parallel_corpus_pruning">http://wiki.apertium.org/wiki/Parallel_corpus_pruning</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org55c81e2" class="outline-3">
<h3 id="org55c81e2"><span class="section-number-3">4.2</span> Connecting nodes</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org3bef536" class="outline-4">
<h4 id="org3bef536"><span class="section-number-4">4.2.1</span> Nodes: Morphological Transducers</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
21 is the number of Turkic languages identified on
<a href="http://wiki.apertium.org/wiki/Turkic_languages">http://wiki.apertium.org/wiki/Turkic_languages</a>, but, according to a source
cited on the `Turkic languages' article on Wikipedia, there are at least 35 of
them. This means that in total about 35 morphological transducers will have to
be developed or generated (or just brought to a production-level coverage,
since many transducers already exist in the Apertium project, see `What was
done' section(s) above. Production-level coverage by the Apertium community is
defined as above 95% coverage on a range corpora. For the rest 5% of words or
so, we'd like the transducer/tagger to probabilistically guess the correct
tags, so that technically no out-of-vocabulary (OOV) words are left in the
output of a transducer.
</p>
</div>
</div>

<div id="outline-container-org3320ce5" class="outline-4">
<h4 id="org3320ce5"><span class="section-number-4">4.2.2</span> To English</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
apertium-eng-kaz, apetium-tat-eng&#x2026;
</p>
</div>
</div>

<div id="outline-container-orgc7aa48e" class="outline-4">
<h4 id="orgc7aa48e"><span class="section-number-4">4.2.3</span> To Russian</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
apertium-kaz-rus, apertium-tat-rus&#x2026;
</p>
</div>
</div>

<div id="outline-container-org8495616" class="outline-4">
<h4 id="org8495616"><span class="section-number-4">4.2.4</span> Intraturkic</h4>
<div class="outline-text-4" id="text-4-2-4">
</div>
<div id="outline-container-org798e311" class="outline-5">
<h5 id="org798e311"><span class="section-number-5">4.2.4.1</span> apertium-tat-bak, apertium-kaz-tat, apertium-chv-tat, apertium-tur-tat, apertium-crh-tur&#x2026;</h5>
</div>
</div>
</div>

<div id="outline-container-orgf84a07a" class="outline-3">
<h3 id="orgf84a07a"><span class="section-number-3">4.3</span> QA and meta-stuff</h3>
<div class="outline-text-3" id="text-4-3">
</div>
<div id="outline-container-org57afacb" class="outline-4">
<h4 id="org57afacb"><span class="section-number-4">4.3.1</span> apertium fitnesse</h4>
<div class="outline-text-4" id="text-4-3-1">
<p>
See <a href="https://gitlab.com/selimcan/apertium-fitnesse">https://gitlab.com/selimcan/apertium-fitnesse</a> and
<del><a href="http://fitnesse.selimcan.org">http://fitnesse.selimcan.org</a></del>.
</p>
</div>
</div>

<div id="outline-container-org21a0c1e" class="outline-4">
<h4 id="org21a0c1e"><span class="section-number-4">4.3.2</span> rbmt-as-a-data-structure = a (Racket-based?) programming language with a syntax similar to what is seen on <a href="http://fitnesse.selimcan.org/FrontPage.ApertiumTurkic.ApertiumKaz">http://fitnesse.selimcan.org/FrontPage.ApertiumTurkic.ApertiumKaz</a>.</h4>
<div class="outline-text-4" id="text-4-3-2">
</div>
<div id="outline-container-org3821270" class="outline-5">
<h5 id="org3821270"><span class="section-number-5">4.3.2.1</span> Rationale</h5>
<div class="outline-text-5" id="text-4-3-2-1">
<p>
Data-driven methods seem to win. The philosophy here is an old and simple one:
to generate data using a rule-based system, fix errors, and use that as a
feedback for improving the rule-based system (or train a statistical/hybrid
system). Somewhat new idea is to make this improving happen on the fly, in a
loop, so that we can generate descent training data even faster. The goal is to
shorten the time it takes to improve a translator in the light of the feedback
given. That is, ideally it has to be a fully automatic process.
</p>
</div>
</div>

<div id="outline-container-orge9d6620" class="outline-5">
<h5 id="orge9d6620"><span class="section-number-5">4.3.2.2</span> Code</h5>
<div class="outline-text-5" id="text-4-3-2-2">
<div class="org-src-container">
<pre class="src src-python" id="org727bc09"><span style="color: #5F7F5F;">#</span><span style="color: #7F9F7F;">!/usr/bin/env python3</span>

<span style="color: #9FC59F;">"""</span>
<span style="color: #9FC59F;">annotate.py: a script for semi-automacally annotating texts *by using* and *for</span>
<span style="color: #9FC59F;">             improving* an Apertium machine translator (or training other</span>
<span style="color: #9FC59F;">             machine translators).</span>

<span style="color: #9FC59F;">INPUT: 6 column, one-token-per-line text in the following format:</span>

<span style="color: #9FC59F;">|surface form |lemma |tags |lexicon |lexicalAffixes |correctlySpelled|</span>

<span style="color: #9FC59F;">In the input, any column, except for the first one with surface forms, can be</span>
<span style="color: #9FC59F;">empty:</span>

<span style="color: #9FC59F;">|&#1091;&#1088;&#1084;&#1072;&#1085;&#1085;&#1072;&#1088;|||||</span>

<span style="color: #9FC59F;">What annotate.py will do is it will fill in the rest of the columns:</span>

<span style="color: #9FC59F;">|&#1091;&#1088;&#1084;&#1072;&#1085;&#1085;&#1072;&#1088;|&#1091;&#1088;&#1084;&#1072;&#1085;|n pl nom|N1||</span>

<span style="color: #9FC59F;">If a cell is already filled in in the input, annotate.py will leave it as it is.</span>

<span style="color: #9FC59F;">Such already-filled-in cells serve as training data for annotate.py for guessing</span>
<span style="color: #9FC59F;">the lemma &amp; lexicon &amp; possibly correct spelling (in cases where the surface form</span>
<span style="color: #9FC59F;">is unknown for the Apertium's morphological transducer), or for selecting</span>
<span style="color: #9FC59F;">correct reading (in cases where Apertium returns several analyses for the given</span>
<span style="color: #9FC59F;">surface form). The script will read in all of the input, train itself on the</span>
<span style="color: #9FC59F;">already annotated part, and fill in the empty cells with its guesses.</span>

<span style="color: #9FC59F;">Ultimately it will modiy the Apertium transducer in place, or spit out a new</span>
<span style="color: #9FC59F;">version of it, after having seen the annotated data.</span>

<span style="color: #9FC59F;">The `lexical affixes' cell might stay empty even in the output of annotate.py,</span>
<span style="color: #9FC59F;">but the cell itself has to be there.</span>

<span style="color: #9FC59F;">An example of a token where the `lexical affixes' field is not empty:</span>
<span style="color: #9FC59F;">|&#1091;&#1088;&#1084;&#1072;&#1085;&#1085;&#1072;&#1088;|&#1091;&#1088;&#1084;&#1072;&#1085;|n pl nom|N1|&#1091;&#1088;&#1084;&#1072;&#1085;&gt;LA&#1088;|</span>

<span style="color: #9FC59F;">For tokens which were misspelled (or incorrectly OCR'd) in the original, there</span>
<span style="color: #9FC59F;">can be an optional sixth cell, where the correct spelling of the surface form</span>
<span style="color: #9FC59F;">is given.</span>

<span style="color: #9FC59F;">The reason for putting the correct spelling in an additional cell and keep</span>
<span style="color: #9FC59F;">the original spelling as it is, is that the data about misspellings is a</span>
<span style="color: #9FC59F;">valuable thing to have (for training an automatic spelling corrector, in</span>
<span style="color: #9FC59F;">particular).</span>

<span style="color: #9FC59F;">Once a particular piece of text is fully annotated, we encourage you to add it</span>
<span style="color: #9FC59F;">to our shared corpus in the `corpus' directory in the repo of the Apertium</span>
<span style="color: #9FC59F;">morphological analyser in question (if the license of the text allows that),</span>
<span style="color: #9FC59F;">with meta-information about the courpus in the following format, and submit</span>
<span style="color: #9FC59F;">a pull request:</span>
<span style="color: #9FC59F;"> </span>
<span style="color: #9FC59F;">BEGIN EXAMPLE</span>
<span style="color: #9FC59F;">&lt;corpus&gt;</span>
<span style="color: #9FC59F;">  &lt;doc title="&#1050;&#1110;&#1096;&#1082;&#1077;&#1085;&#1090;&#1072;&#1081; &#1093;&#1072;&#1085;&#1079;&#1072;&#1076;&#1072;" author="&#1040;. &#1076;&#1077; &#1057;&#1077;&#1085;&#1090;-&#1069;&#1082;&#1079;&#1102;&#1087;&#1077;&#1088;&#1080;"</span>
<span style="color: #9FC59F;">       translator="&#1046;. &#1178;&#1086;&#1085;&#1072;&#1077;&#1074;&#1072;" pub="2013" lang="kk" origlang="fr"</span>
<span style="color: #9FC59F;">       source="kitap.kz/12345/abcde.html" license="allRightsReserved"</span>
<span style="color: #9FC59F;">       annotators="&#1052;&#1241;&#1093;&#1084;&#1199;&#1090; &#1057;&#1072;&#1083;&#1099;&#1179;&#1090;&#1257;&#1083;&#1077;&#1091;&#1096;&#1110; (optional@email.com)"&gt;</span>
<span style="color: #9FC59F;">    &lt;p&gt;</span>
<span style="color: #9FC59F;">      &lt;s&gt;&#1041;&#1110;&#1088;&#1076;&#1077;, &#1072;&#1083;&#1090;&#1100; &#1078;&#1072;&#1089;&#1090;&#1072;&#1171;&#1099; &#1082;&#1077;&#1079;&#1110;&#1084;&#1076;&#1077; [...]</span>
<span style="color: #9FC59F;">        &lt;t&gt;|&#1041;&#1110;&#1088;&#1076;&#1077;|&#1073;&#1110;&#1088;&#1076;&#1077;|adv|ADV||&lt;/t&gt;</span>
<span style="color: #9FC59F;">        &lt;t&gt;|&#1072;&#1083;&#1090;&#1100;|&#1072;&#1083;&#1090;&#1099;|num|NUM||&#1072;&#1083;&#1090;&#1099;|&lt;/t&gt;</span>
<span style="color: #9FC59F;">        [...]</span>
<span style="color: #9FC59F;">      &lt;/s&gt;</span>
<span style="color: #9FC59F;">      [...]</span>
<span style="color: #9FC59F;">   &lt;/p&gt;</span>
<span style="color: #9FC59F;">  &lt;/doc&gt;    </span>
<span style="color: #9FC59F;">&lt;/corpus&gt;</span>
<span style="color: #9FC59F;">END EXAMPLE</span>

<span style="color: #9FC59F;">USAGE:</span>
<span style="color: #9FC59F;">"""</span>

<span style="color: #F0DFAF; font-weight: bold;">from</span> collections <span style="color: #F0DFAF; font-weight: bold;">import</span> namedtuple


<span style="color: #5F7F5F;">##################</span>
<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Data definitons</span>


<span style="color: #5F7F5F;">## </span><span style="color: #7F9F7F;">Token is a Token(String, String, ListOfString, String, String, StringOrNone).</span>

<span style="color: #DFAF8F;">T_0</span> = [<span style="color: #CC9393;">"&#1091;&#1088;&#1084;&#1072;&#1085;&#1085;&#1072;&#1088;"</span>, <span style="color: #CC9393;">""</span>, [], <span style="color: #CC9393;">""</span>, <span style="color: #CC9393;">""</span>, <span style="color: #BFEBBF;">None</span>]
<span style="color: #DFAF8F;">T_1</span> = [<span style="color: #CC9393;">"&#1091;&#1088;&#1084;&#1072;&#1085;&#1085;&#1072;&#1088;"</span>, <span style="color: #CC9393;">"&#1091;&#1088;&#1084;&#1072;&#1085;"</span>, [<span style="color: #CC9393;">"n"</span>, <span style="color: #CC9393;">"pl"</span>, <span style="color: #CC9393;">"nom"</span>], <span style="color: #CC9393;">"N1"</span>, <span style="color: #CC9393;">""</span>, <span style="color: #BFEBBF;">None</span>]
<span style="color: #DFAF8F;">T_2</span> = [<span style="color: #CC9393;">"&#1072;&#1083;&#1090;&#1100;"</span>, <span style="color: #CC9393;">"&#1072;&#1083;&#1090;&#1099;"</span>, [<span style="color: #CC9393;">"num"</span>, <span style="color: #CC9393;">"pl"</span>, <span style="color: #CC9393;">"nom"</span>], <span style="color: #CC9393;">"N1"</span>, <span style="color: #CC9393;">""</span>, <span style="color: #CC9393;">"&#1072;&#1083;&#1090;&#1099;"</span>]

</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd49cdc0" class="outline-4">
<h4 id="orgd49cdc0"><span class="section-number-4">4.3.3</span> Problem 404</h4>
<div class="outline-text-4" id="text-4-3-3">
<p>
Rationale: out-of-vocabulary words lead to not firing transfer rules. Not firing
transfer rules lead to bad translation. Bad translation leads to sadness.
</p>

<p>
Instance of: stemming, lemmatization, sequence labeling, pos tagging,
             classification, inference in graphical models (depending on how
             exactly it is formulated)
</p>

<p>
Possible formulations:
</p>
</div>

<div id="outline-container-orgf038608" class="outline-5">
<h5 id="orgf038608"><span class="section-number-5">4.3.3.1</span> Problem 404.a</h5>
<div class="outline-text-5" id="text-4-3-3-1">
<div class="org-src-container">
<pre class="src src-text">## INPUT-1:
## ...
## ^&#1072;&#1085;&#1072;&#1089;&#1099;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;pl&gt;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;sg&gt;$
## ^&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;/*&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;$
## ^&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;pl&gt;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;sg&gt;$
## ^&#1082;&#1099;&#1079;&#1099;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;pl&gt;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;sg&gt;$
## ...
##
## OUTPUT-1:
## ...
## ^&#1072;&#1085;&#1072;&#1089;&#1099;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;pl&gt;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;sg&gt;$
## ^&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;/&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;&lt;np&gt;&lt;ant&gt;&lt;f&gt;&lt;nom&gt;$
## ^&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;pl&gt;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;sg&gt;$
## ^&#1082;&#1099;&#1079;&#1099;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;pl&gt;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;+&#1080;&lt;cop&gt;&lt;aor&gt;&lt;p3&gt;&lt;sg&gt;$
## ...
</pre>
</div>

<p>
That is, classes are entire tag sequences, no stemming or lemmatization
required. Issue: probably too many classes to be feasible without a gazillion
gigabytes of training data (although there are papers on multiclass
classification for cases when there are even more, google 'Training Highly
Multiclass Classifiers' for an example)
</p>

<p>
For example, if we run Tatar Quran through apertium-tat:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgf427eb2">cat ../../../turkiccorpora/tat.quran.nughmani.txt | <span style="color: #CC9393;">\</span>
apertium -d ../../apertium-languages/apertium-tat tat-tagger | <span style="color: #CC9393;">\</span>
grep -oP <span style="color: #CC9393;">"(&lt;[[:alnum:]]+&gt;)*"</span> | sort | uniq | wc -l
</pre>
</div>

<p>
we get
</p>

<pre class="example">
991

</pre>

<p>
uniq tag sequences.
</p>

<div class="org-src-container">
<pre class="src src-text">n-px3sp-nom  -&gt;  ?  -&gt;  np-ant-m-nom  -&gt; n-px3sp-nom
    |            |           |                |
  &#1072;&#1085;&#1072;&#1089;&#1099;      &#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;  &#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;          &#1082;&#1099;&#1079;&#1099;

P(n-px3sp-nom), P(np-ant-m-nom), P(n-px3sp-nom) = 1
</pre>
</div>

<p>
What we want instead of the ? is (not too sure)
</p>

<ul class="org-ul">
<li>probability distribution of 991 tag sequences observed ?</li>
<li>a tag that maximizes the probability of the entire sequence ?</li>
</ul>

<p>
Belief propagation?
</p>
</div>
</div>

<div id="outline-container-orgfcbfcd2" class="outline-5">
<h5 id="orgfcbfcd2"><span class="section-number-5">4.3.3.2</span> Problem 404.b</h5>
<div class="outline-text-5" id="text-4-3-3-2">
<div class="org-src-container">
<pre class="src src-text">## INPUT-2:
## ...
## ^&#1072;&#1085;&#1072;&#1089;&#1099;/&#1072;&#1085;&#1072; N1$
## ^&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;/*&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;$
## ^&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085; NP-ANT-M$
## ^&#1082;&#1099;&#1079;&#1099;/&#1082;&#1099;&#1079; N1$
## ...
##
## OUTPUT-2:
## ...
## ^&#1072;&#1085;&#1072;&#1089;&#1099;/&#1072;&#1085;&#1072; N1$
## ^&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;/&#1061;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072; NP-ANT-F$
## ^&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085; NP-ANT-M$
## ^&#1082;&#1099;&#1079;&#1099;/&#1082;&#1099;&#1079; N1$
## ...
</pre>
</div>

<p>
This doesn't solve the original problem, and rather might help with expanding
dictionaries.
</p>
</div>
</div>

<div id="outline-container-org77df442" class="outline-5">
<h5 id="org77df442"><span class="section-number-5">4.3.3.3</span> Problem 404.c</h5>
<div class="outline-text-5" id="text-4-3-3-3">
<div class="org-src-container">
<pre class="src src-text">## INPUT-3:
## ...
## ^&#1072;&#1085;&#1072;&#1089;&#1099;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;$
## ^&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;/*&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;$
## ^&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;$
## ^&#1082;&#1099;&#1079;&#1099;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;$
## ...
##
## OUTPUT-3:
## ...
## ^&#1072;&#1085;&#1072;&#1089;&#1099;/&#1072;&#1085;&#1072;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;$
## ^&#1093;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;/&#1061;&#1241;&#1081;&#1088;&#1077;&#1083;&#1085;&#1080;&#1089;&#1072;&lt;np&gt;&lt;ant&gt;&lt;f&gt;&lt;nom&gt;$
## ^&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;/&#1053;&#1241;&#1175;&#1084;&#1077;&#1090;&#1076;&#1080;&#1085;&lt;np&gt;&lt;ant&gt;&lt;m&gt;&lt;nom&gt;$
## ^&#1082;&#1099;&#1079;&#1099;/&#1082;&#1099;&#1079;&lt;n&gt;&lt;px3sp&gt;&lt;nom&gt;$
## ...
</pre>
</div>

<p>
Same as in (1), but with lemmatization.
</p>

<p>
Background reading:
</p>

<ul class="org-ul">
<li>Apertium Tagger related</li>
<li>Zhenis et al.'s paper on Hybrid Kazakh disambiguation tool</li>
<li>NLTK on stemming, lemmatization and pos-tagging</li>
<li>Guessing with CG?</li>
<li>Y&amp;M on stemming, lemmatization and pos-tagging</li>
<li>M&amp;S on the same</li>
<li>Lemming and other tools of Munich University's mighty CIS group</li>
</ul>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgac7e3f6" class="outline-2">
<h2 id="orgac7e3f6"><span class="section-number-2">5</span> ROADMAP</h2>
</div>

<div id="outline-container-orgd7218a7" class="outline-2">
<h2 id="orgd7218a7"><span class="section-number-2">6</span> NOTES</h2>
<div class="outline-text-2" id="text-6">
</div>
<div id="outline-container-orge7d67f9" class="outline-3">
<h3 id="orge7d67f9"><span class="section-number-3">6.1</span> Methods of auditing a monolingual dictionary</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Take stems contained in it and pass them through the transducer to see whether
they get multiple analyses (some of which might be wrong). Better yet, use the
<code>lexc2dix</code> library, parse the .lexc file with it, and get the list of stems
which are linked to 2 or more continuation lexicons. :idea:</li>
</ul>
</div>
</div>

<div id="outline-container-orgca16a17" class="outline-3">
<h3 id="orgca16a17"><span class="section-number-3">6.2</span> Principles of tagset choice</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>surface form has to be deterministically reconstructuble from lemma + tags /
subreadings</li>
</ul>
</div>
</div>

<div id="outline-container-org8a8f575" class="outline-3">
<h3 id="org8a8f575"><span class="section-number-3">6.3</span> Minimal monolingual Apertiumpp package</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>transducers + disambiguator</li>
<li>spellchecker</li>
<li>annotated corpus with an interface</li>
<li>virtual keyboard</li>
<li>Common Voice's interface translations</li>
<li>sentences for Common Voice</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org2d5a29e" class="outline-2">
<h2 id="org2d5a29e"><span class="section-number-2">7</span> TODAY</h2>
<div class="outline-text-2" id="text-7">
<ul class="org-ul">
<li>check at least the first 2500 words from 2005 Explanatory dictionary of Tatar
and make sure that they are present in apertium-tat and their pos tags in the
latter are correct</li>
</ul>
</div>
</div>

<div id="outline-container-orgb3e7728" class="outline-2">
<h2 id="orgb3e7728"><span class="section-number-2">8</span> ON THE NEXT "META"-WORK DAY</h2>
<div class="outline-text-2" id="text-8">
<ul class="org-ul">
<li>find and add Bible translations in \(l\) for all \(l\) in \(L\) to data4apertium
(see notes on the Bible corpus above):
<ul class="org-ul">
<li>kaz, done</li>
<li>tat, done</li>
<li>kir, done</li>
<li>tyv, done</li>
<li>tur,</li>
<li>chv, done</li>
<li>kum, done</li>
<li>kaa, done</li>
<li>uzb, done</li>
<li>sah, done</li>
<li>crh, done</li>
<li>krc, done</li>
<li>bak,</li>
<li>nog, done</li>
<li>gag,</li>
<li>tuk,</li>
<li>uig,</li>
<li>alt, done</li>
<li>kjh, done</li>
<li>ota,</li>
<li>aze</li>
</ul></li>

<li>for all apertium-l and apertium-x-l and apertium-l-x, add a circleci script which:
<ul class="org-ul">
<li>builds the package</li>
<li>measures its coverage on New Testament</li>
<li>checks that it hasn't decreased</li>
<li>deploys NT|cov| badge somewhere public, <del>say Amazon S3</del>, so that it becomes visible
on apertium.github.io/status.html and apertium.github.io/turkic.html</li>
<li>keep in mind the discussion we had on 29.04.2019 on #apertium on using S3</li>
</ul></li>

<li>add a list of all turkic monolingual packages and translators with a turkic on either side, along with Bible|cov| badge
to apertium.github.io/turkic.html It should resemble <a href="http://wiki.apertium.org/wiki/Turkic_languages">http://wiki.apertium.org/wiki/Turkic_languages</a>
(but should show information from the latest git revisions).</li>
</ul>
</div>
</div>

<div id="outline-container-org41edc63" class="outline-2">
<h2 id="org41edc63"><span class="section-number-2">9</span> ON THE NEXT "APERTIUM-TURKIC LINGUISTIC DATA" DAY</h2>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2019-04-30 Tue 17:50</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
